//    1- Проблема с рюкзаком с использованием рекурсии:


#include <stdio.h>

// Служебная функция, которая возвращает
// максимум два целых числа.

int max(int a, int b) { return (a > b) ? a : b; }

// Возвращает максимальное значение, которое может быть
// положить в рюкзак вместимостью w .

int knapSack(int W, int wt[], int val[], int n)
{
    // Базовый корпус
    if (n == 0 || W == 0)
        return 0;
        
// Если вес n-го предмета больше, чем
// Вместимость рюкзака W, то этот предмет не может
// быть включенным в оптимальное решение

     if (wt[n - 1] > W)
        return knapSack(W, wt, val, n - 1);

// Возвращает максимум два обращения:
    // (1) n-й включенный элемент
    // (2) не входит в комплект
    
     else
        return max(
            val[n - 1]
                + knapSack(W - wt[n - 1], wt, val, n - 1),
            knapSack(W, wt, val, n - 1));
            
            

int main()
{
    int val[] = { 60, 100, 120 };
    int wt[] = { 10, 20, 30 };
    int W = 50;
    int n = sizeof(val) / sizeof(val[0]);
    printf("%d", knapSack(W, wt, val, n));
    return 0;
}

//Временная сложность: O(2^N)
//Вспомогательное пространство: O(N), пространство стека, необходимое для рекурсии

//Примечание: Следует отметить, что приведенная выше функция вычисляет одни и те же подзадачи снова и снова. Смотрите следующее дерево рекурсии, K(1, 1) вычисляется дважды.



// 2- Проблема с рюкзаком с использованием динамического программирования:

// Динамическое программирование, основанное
// решение проблемы с рюкзаком 0-1

#include <stdio.h>
 
// A utility function that returns
// maximum of two integers

int max(int a, int b) { return (a > b) ? a : b; }

// Возвращает максимальное значение, которое
// может быть помещено в рюкзак вместимостью W.


int knapSack(int W, int wt[], int val[], int n)
{
    int i, w;
    int K[n + 1][W + 1];
    
    
    
  // Построить таблицу K[][] снизу вверх.
  
  
   for (i = 0; i <= n; i++) {
        for (w = 0; w <= W; w++) {
            if (i == 0 || w == 0)
                K[i][w] = 0;
            else if (wt[i - 1] <= w)
                K[i][w] = max(val[i - 1]
                                  + K[i - 1][w - wt[i - 1]],
                              K[i - 1][w]);
            else
                K[i][w] = K[i - 1][w];
        }
    }
 
    return K[n][W];
}
 
 
 int main()
{
    int val[] = { 60, 100, 120 };
    int wt[] = { 10, 20, 30 };
    int W = 50;
    int n = sizeof(val) / sizeof(val[0]);
    printf("%d", knapSack(W, wt, val, n));
    return 0;
}


Временная сложность: O(N * W). где ‘N’ - количество элементов, а ‘W’ - вместимость. 
Вспомогательное пространство: O(N * W). Использование двумерного массива размером ‘N*W’.
 




 
